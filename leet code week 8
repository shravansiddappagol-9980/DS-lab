#include <stdlib.h>
#include <stdbool.h>

typedef struct {
    long val;
    int prev;
    int next;
    bool active;
} Node;

// Helper to check if array is non-decreasing
bool check_sorted(Node* nodes, int head) {
    int cur = head;
    while (cur != -1) {
        int nxt = nodes[cur].next;
        if (nxt != -1 && nodes[cur].val > nodes[nxt].val) return false;
        cur = nxt;
    }
    return true;
}

int minimumPairRemoval(int* nums, int numsSize) {
    if (numsSize <= 1) return 0;

    Node* nodes = (Node*)malloc(sizeof(Node) * numsSize);
    for (int i = 0; i < numsSize; i++) {
        nodes[i].val = nums[i];
        nodes[i].prev = i - 1;
        nodes[i].next = (i == numsSize - 1) ? -1 : i + 1;
        nodes[i].active = true;
    }

    int ops = 0;
    int head = 0;

    while (!check_sorted(nodes, head)) {
        // Find leftmost pair with minimum sum
        long min_sum = 2147483647L * 2; // large initial value
        int idx = -1;

        int cur = head;
        while (cur != -1 && nodes[cur].next != -1) {
            if (!nodes[cur].active) { cur = nodes[cur].next; continue; }
            int nxt = nodes[cur].next;
            if (!nodes[nxt].active) { cur = nodes[nxt].next; continue; }

            long s = nodes[cur].val + nodes[nxt].val;
            if (s < min_sum) {
                min_sum = s;
                idx = cur; // leftmost min pair
            }
            cur = nxt;
        }

        // Merge nodes[idx] and nodes[idx].next
        int j = nodes[idx].next;
        nodes[idx].val += nodes[j].val;
        nodes[j].active = false;

        // Remove j from linked list
        int r = nodes[j].next;
        nodes[idx].next = r;
        if (r != -1) nodes[r].prev = idx;

        // Update head if needed
        if (idx == head && nodes[head].prev != -1) head = idx;

        ops++;
    }

    free(nodes);
    return ops;
}
